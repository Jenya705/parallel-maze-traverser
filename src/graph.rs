use std::io;

use crate::{
    bfs::{handle_single_4d_state, ensure_capacity},
    delta_list::{BitSetDeltaList, DeltaList},
    end_state,
    instructions::collect_positions4d,
    Coordinate, Map,
};

/// Generiert eine DOT-Datei, die den Graphen von der BFS-Suche enth√§lt.
pub fn graph<const RESPECT_HOLES: bool>(
    width: Coordinate,
    height: Coordinate,
    maps: &[Map; 2],
    instructions: &Vec<[bool; 2]>,
) {
    let mut file = std::fs::File::create("graph.dot").unwrap();
    gen_graph::<_, RESPECT_HOLES>(
        width,
        height,
        maps,
        &collect_positions4d::<RESPECT_HOLES>(
            instructions.iter().cloned(),
            maps,
            &mut [[0; 2]; 2],
        ),
        &mut file,
    )
    .unwrap();
}

pub fn gen_graph<W: io::Write, const RESPECT_HOLES: bool>(
    width: Coordinate,
    height: Coordinate,
    maps: &[Map; 2],
    highlight: &Vec<[Coordinate; 4]>,
    mut write: W,
) -> io::Result<()> {
    write!(write, "DiGraph G {{")?;

    let width_u = width as usize;
    let height_u = height as usize;
    let tiles_count = width_u * height_u;

    let mut tasks = vec![[0 as Coordinate; 4]];
    let mut output = vec![];
    let mut delta_list = BitSetDeltaList::new(tiles_count.pow(2));
    delta_list.set::<true>(0, 1);

    while !tasks.is_empty() {
        ensure_capacity(&tasks, &mut output);

        for state in tasks.drain(..) {
            let l = output.len();

            // SAFETY: called ensure_capacity and all states are generated by the following function
            unsafe {
                handle_single_4d_state::<RESPECT_HOLES>(
                    &maps,
                    width_u,
                    height_u,
                    tiles_count,
                    state,
                    &mut output,
                    &mut delta_list,
                );
            }

            for i in l..output.len() {
                write!(write, r#""{:?}" -> "{:?}";"#, state, output[i]).unwrap();
            }
        }

        std::mem::swap(&mut tasks, &mut output);
    }

    let end = end_state(width, height);

    for &highlight in highlight {
        if highlight == end || highlight == [0; 4] {
            continue;
        }
        write!(write, r#""{:?}" [color=blue];"#, highlight)?;
    }

    write!(
        write,
        r#""{:?}" [color=green];"{:?}" [color=red];"#,
        [0; 4], end,
    )?;
    write!(write, "}}")?;

    Ok(())
}
